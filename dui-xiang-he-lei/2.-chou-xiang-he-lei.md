# 2. 抽象和类

## 2.1 C++ 中的类

### 构思类

首先，必须考虑如何表示股票，一种比较现实的方法是，必须记录最初购买的价格和购买日期等内容，还必须管理诸如拆股等事件，我们对其进行简化，具体来说

可执行的操作

* 获得股票
* 增持
* 卖出股票
* 更新股票价格
* 显示关于所持股票的价格

股票信息

* 公司名称
* 所持股票数量
* 每股的价格
* 股票总值

### 定义类

接下来，定义类，一般来说，类规范由两个部分组成

* **类声明**：以数据成员的方式描述部分，以成员函数方式描述共有接口
  * 提供类的蓝图
* **类方法定义**：描述如何实现成员函数
  * 提供类的细节

### 接口

接口是一个共享框架，对于类，我们说公共接口，接口让程序员编写与类对象交互的代码，从而让程序可以使用类对象

* 公共：使用类的程序
* 接口：由编写类的人提供的方法组成

通常，C++ 程序员将**接口**（类定义）放在**头文件**中，将**实现**（类方法的代码）放在**源代码文件**中，且遵循**类名首字母大写**的不成文约定

### 头文件定义

```cpp
// stock00.h
#ifndef CODE_STOCK00_H
#define CODE_STOCK00_H


#include <string>
class Stock
{
private:
    std::string company;    // 公司名称
    long shares;            // 持有股票数量
    double share_val;       // 每股价格
    double total_val;       // 股票总价格
    void set_tot(){total_val = shares * share_val}

public:
    void acquire(const std::string & co, long n, double pr);
    void buy(long num, double price);
    void sell(long num, double price);
    void update(double price);
    void show();
};


#endif //CODE_STOCK00_H

```

### 访问控制与数据隐藏

关键字 **private** 和 **public** 描述了对类成员的访问呢控制

* 使用类对象的程序都可以**直接访问到公有部分**，但**只能通过公有成员函数（或友元函数）**来访问对象的**私有成员**
* 公有函数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口
* 类设计尽可能将公有接口与实现细节分开，公有接口表示设计的抽象组件，将实现细节放在一起并且它们与抽象分开的行为被称为**封装**（数据隐藏，将数据放在类的私有部分中就是一种封装，另一种封装是将类函数定义和类声明放在不同的文件中）
* 通常，**数据项放在私有部分，组成类接口的成员函数放在公有部分**
* 类声明中，**默认的访问声明**是 **private**，因此也可以不必声明

### 类和结构

C++ 对结构进行了拓展，使之与类具有相同的特性，它们之间唯一的区别是

* **结构**的默认访问类型是 **public**
* **类**的默认访问类型为 **private**

## 2.2 实现类成员函数

定义成员函数时，与常规函数的定义由两个不同

* 定义成员函数时，使用作用域解析运算符（::）来标识函数所属的类
* 类方法可以访问类的 private 组件

### 函数头定义

例如，在上面的示例中 update\(\) 成员函数的函数头如下

```cpp
void Stock::update(double price)
```

* 我们可以将另一个类的成员函数也命名为 update\(\)
* 作用域解析运算符确定了方法定义对应的类的身份

同时，类方法可以访问私有成员，例如，show\(\) 方法中可以使用这样的代码

```cpp
std::cout << "Company: " << company << endl
          << " Shares:" << shares << endl
          << " Share Prices: $" << share_val << endl
          << " Total Worth: $" << total_val << endl;
```

* 其中，company 和 shares 等都是 Stock 类的私有数据成员

### 实现效果

```cpp
// stock00.cpp
#include <iostream>
#include "stock00.h"
using namespace std;

// 首次购买
void Stock::acquire(const std::string &co, long n, double pr)
{
    company = co;
    if(n < 0)
    {
        cout << "Number of shares can't be negative; " << company
         << " shares set to 0." << endl;
        shares = 0;
    }else
    {
        shares = n;
    }
    share_val = pr;
    set_tot();
}
// 买入
void Stock::buy(long num, double price) {
    if (num < 0) {
        cout << "Number of shares purchased can't be negative." << endl;
        cout << "Transaction is aborted." << endl;
    } else
    {
        shares += num;
        share_val = price;
        set_tot();
    }
}
// 抛出
void Stock::sell(long num, double price)
{
    if(num < 0)
    {
        cout << "Number of shares sold can't be negative." << endl;
        cout << "Transaction is aborted." << endl;
    }else
    {
        shares -= num;
        share_val = price;
        set_tot();
    }
}
// 更新每股价格
void Stock::update(double price)
{
    share_val = price;
    set_tot();
}

void Stock::show()
{
    cout << "Company: " << company << endl
    << " Shares:" << shares << endl
    << " Share Prices: $" << share_val << endl
    << " Total Worth: $" << total_val << endl;
}
```

### 内联方法（函数）

其定义位于类声明中的函数都将自动称为内联函数

* 示例中，Stock::set\_tot\(\) 是一个内联函数

如果愿意，也可以在类声明之外定义成员函数，并使其称为内联函数，为此，只需要在类实现部分定义函数时使用 inline 限定符即可

```cpp
class Stock
{
private:
    ...
    void set_tot();
public:
    ...    
};

inline void Stock::set_tot()
{
    total_val = shares * share_val;
}
```

### 调用方法（函数）

创建两个 Stock 对象，一个为 kate，另一个为 joe，和结构成员一样，通过成员运算符

```cpp
kate.show();
joe.show();
```

* 在 OOP 中，调用成员函数被称为**发送消息**，因此将同样的消息发送给两个不同的对象将调用同一个方法，但该方法被用于两个不同的对象

## 2.3 使用类

要创建类对象，可以声明类变量，也可以使用 new 为类对象分配存储空间，可以将对象作为函数的参数和返回值，也可以将一个对象赋给另一个

```cpp
// uststock0.cpp
#include <iostream>
#include "stock00.h"
#include "stock00.cpp"

int main()
{
    Stock fluffy_the_cat;
    fluffy_the_cat.acquire("NanoSmart",20,12.50);
    fluffy_the_cat.show();
    fluffy_the_cat.buy(15, 18.125);
    fluffy_the_cat.show();
    fluffy_the_cat.sell(400,20.00);
    fluffy_the_cat.show();
    fluffy_the_cat.buy(300000,40.125);
    fluffy_the_cat.show();
    fluffy_the_cat.sell(300000,0.125);
    fluffy_the_cat.show();
    return 0;
}
```



