# 2. 函数和数组

## 2.1 介绍

如下面类型的函数

```cpp
int sum_arr(int arr[], int n)
{
    ...
}
```

* arr 实际上并不是一个数组，而是一个**指针**
* 在编写函数的其余部分时，可以将 arr 看作是数组

## 2.2 函数如何使用指针来处理数组

在大多数情况下，C++ 和 C 一样，将数组名视为指针，也就是

```cpp
cookies = &cookies[0]
```

如果执行下面类型的函数调用

```cpp
int sum = sum_arr(cookies, ArSize);
```

* cookies 是**数组名**，根据 C++ 规则， **cokkies 是第一个元素的地址**，因此函数传递的是地址
* 由于数组的元素为 int，因此 cookies 的类型必须是 int 指针，即 **int \***

这表明，正确的函数头应该是这样的

```cpp
int sum_arr(int * arr, int n)
{
    ...
}
```

* 其中 int \* arr 替换了 int arr\[\]，这两个函数头都是正确的且等价的
* 在 C++ 中，**当且仅当**用于函数头或者函数原型中时了，**int \* arr 和 int arr\[\] 的含义才是相同的**
* 然而数组表示法 int arr\[\] 提醒用户，arr 不仅指向 int，而且还指向 **int 数组的第一个 int**

由于变量 arr 是一个指针

* 动态数组指出，数组名和指针都可以通过**方括号**来访问数组元素
*  arr + 1 **表示指向下一个元素**

## 2.3 将数组作为参数意味着什么

* 实际上并没有将数组的内容传递给函数，而是将**数组的位置**、**包含的元素种类**以及**元素数目（变量 n）**提交给函数，函数将使用该变量的拷贝
* 并不违反 C++ 按值传递的原则，只是**传递了一个地址**，这个地址被赋值给了一个新的变量
* 传递**常规变量**的时候，C++ 使用该变量的拷贝，传递**数组**时，C++ 使用**原来的数组**

优点

* 节省计算机内存，减少复制数据所需要的时间

缺点

* 增加了破坏原始数据的风险

## 2.4 更多的数组函数示例

### 使用 const 保护数组

如果设置了这样的函数

```cpp
void showArray(const double ar[], int n)\
{
    ...
}
```

* 使用 const 修饰 ar，意味着 ar 指向的是常量数据，**不能使用它修改该数据**，也就是说，可以使用 ar\[0\] 这样的值，但是不能修改
* showArray\(\) 将数组视为只读数据

### 指针和 const

可以使用两种不同的方式将 const 关键字用于指针

* 第一种方法是让**指针指向一个常量对象**，这样可以**防止使用指针来修改所指向的值**
* 第二种方法是将**指针本身声明为常量**，这样可以**防止改变指针指向的位置**





