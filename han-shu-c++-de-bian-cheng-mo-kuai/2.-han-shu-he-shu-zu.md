# 2. 函数、数组、指针和 const

## 2.1 介绍

如下面类型的函数

```cpp
int sum_arr(int arr[], int n)
{
    ...
}
```

* arr 实际上并不是一个数组，而是一个**指针**
* 在编写函数的其余部分时，可以将 arr 看作是数组

## 2.2 函数如何使用指针来处理数组

在大多数情况下，C++ 和 C 一样，将数组名视为指针，也就是

```cpp
cookies = &cookies[0]
```

如果执行下面类型的函数调用

```cpp
int sum = sum_arr(cookies, ArSize);
```

* cookies 是**数组名**，根据 C++ 规则， **cokkies 是第一个元素的地址**，因此函数传递的是地址
* 由于数组的元素为 int，因此 cookies 的类型必须是 int 指针，即 **int \***

这表明，正确的函数头应该是这样的

```cpp
int sum_arr(int * arr, int n)
{
    ...
}
```

* 其中 int \* arr 替换了 int arr\[\]，这两个函数头都是正确的且等价的
* 在 C++ 中，**当且仅当**用于函数头或者函数原型中时了，**int \* arr 和 int arr\[\] 的含义才是相同的**
* 然而数组表示法 int arr\[\] 提醒用户，arr 不仅指向 int，而且还指向 **int 数组的第一个 int**

由于变量 arr 是一个指针

* 动态数组指出，数组名和指针都可以通过**方括号**来访问数组元素
*  arr + 1 **表示指向下一个元素**

## 2.3 将数组作为参数意味着什么

* 实际上并没有将数组的内容传递给函数，而是将**数组的位置**、**包含的元素种类**以及**元素数目（变量 n）**提交给函数，函数将使用该变量的拷贝
* 并不违反 C++ 按值传递的原则，只是**传递了一个地址**，这个地址被赋值给了一个新的变量
* 传递**常规变量**的时候，C++ 使用该变量的拷贝，传递**数组**时，C++ 使用**原来的数组**

优点

* 节省计算机内存，减少复制数据所需要的时间

缺点

* 增加了破坏原始数据的风险

## 2.4 更多的数组函数示例

### 使用 const 保护数组

如果设置了这样的函数

```cpp
void showArray(const double ar[], int n)\
{
    ...
}
```

* 使用 const 修饰 ar，意味着 ar 指向的是常量数据，**不能使用它修改该数据**，也就是说，可以使用 ar\[0\] 这样的值，但是不能修改
* showArray\(\) 将数组视为只读数据

## 2.5 指针和 const

可以使用两种不同的方式将 const 关键字用于指针

### 情况 1

* 第一种方法是让**指针指向一个常量对象**，这样可以**防止使用指针来修改所指向的值**
* 第二种方法是将**指针本身声明为常量**，这样可以**防止改变指针指向的位置**

```cpp
int age = 39;
const int * pt = &age;
int sage = 80;
pt = &sage; // 合理

*pt += 1;   // 不合理
cin >> *pt; // 不合理
*pt = 20;   // 不合理
age = 20;   // 合理！
```

* pt 指向一个 const int，因此不能用 pt 来修改这个值
* \*pt 的值为 const，不能被修改
* pt 的声明并不意味着它指向是值实际上就是一个常量，只是对于 pt 而言，这个值是常量
* pt 指向 age，pt 是常量，但是 age 本身不是常量，可以直接通过 age 变量来修改 age 的值
* const 只能防止修改 pt 指向的值，而不能防止修改 pt 的值，也就是说可以将一个新地址赋值给 pt，但仍不能用 pt 来修改它指向的值

### 情况 2

```cpp
int sloth = 3;
const int * ps = &sloth;      // 指向 const int 的指针，不可以修改 *ps
int * const finger = &sloth;  // const 的指针，指向 int，不可以修改 finger
```

* finger 和 \*ps 是 const 的
* \*finger 和 ps 不是 const 的

### 情况 3

也可以声明指向 const 对象的 const 指针

```cpp
double trouble = 2.0E30;
const double * const stick = &trouble;
```

### 情况 4

```cpp
// case1
const float g_earth = 9.80;
const float * pe = &g_earth; // 合理
// case2
const float g_moon = 1.63;
float * pm = &g_moon;        // 不合理
```

* 对于第一种情况，g\_earth 和 pe 都不可以修改值
* C++ 禁止第二种情况

### 情况 5

如果有一个由 const 组成的数组

```cpp
const int months[12] = {1,2,3,4,5,6,7,8,9,10,11,12};

int sum(int arr[], int n)
{
    ...
}

int j = sum(months, 12);  // 不合理
```

* 上述函数试图将 const 指针 months 赋值给非 const 指针 arr，编译器将禁止这种调用

