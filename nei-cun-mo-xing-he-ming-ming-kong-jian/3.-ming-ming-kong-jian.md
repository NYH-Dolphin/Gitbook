# 3. 名称空间

## 3.1 传统 C++ 的名称空间

### 声明区域 declaration rigion

可以在其中进行声明的区域

* **在函数外声明的变量**
  * 声明区域为其声明所在的文件
* **在函数中声明的变量**
  * 声明区域为其声明所在的代码块

### 潜在作用域 potential scope

变量的潜在作用域从**声明点开始，到其声明区域的结尾**，且并非在其潜在作用域的任何位置都可见，它可能被另外一个在嵌套声明的同名变量所**隐藏**

C++ 关于全局变量和局部变量的规则定义了一种名称空间的层次，每个声明区域都可以声明名称，这些名称独立于其它声明区域中声明的名称，在一个函数中声明的局部变量与不会在另一个函数中声明的局部变量发生冲突

```cpp
#include <iostream>
// 声明区 全局名称空间
using namespace std;
void orp(int);
int ro = 10;
int main()
{ // 声明区 代码段
    int goo;
    ...
    for (int i = 0; i < ro; i++)
    { // 声明区 代码段
        int temp = 0;
        ...
        int goo = temp * i;
        ...
    }
    ...
    return 0;
}

void orp(int ex)
{ // 声明区 代码段
    int m;
    ...
    { // 声明区 代码段
        itn ro = 2;
    }
}
```

## 3.2 新的名称空间特性

### 名称空间的命名

* C++ 新增的功能，通过定义一种新的声明区域来创建命名的名称空间，这样做的目的之一是提供一个声明名称的区域
* 一个名称空间中的名称不会与另外一个名称空间中的相同名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西

```cpp
namespace Jack{
    double pail;
    void fetch();
    int pal;
    struct Well{...};
}

namespace Jill{
    double bucket(double n){...};
    double fetchl
    int pal;
    struct Hill{...};
}
```

* 名称空间可以说**全局**的，也可以**位于另外一个名称空间**中
* 名称空间**不能位于代码块**中
* 默认情况，名称空间中声明的名称具有**外部链接性**（除非它引用了常量）

当然，需要有一种方法来访问名称空间中的名称，最简单的方法是通过**作用域解析运算符（::）**

```cpp
Jack::pail = 12.34; // 使用一个变量
Jill::Hill mole;    // 创建一个叫 Hill 的结构
Jack::fetch();      // 调用一个函数
```

* 未被装饰的名称（如 pail）称为**未限定名称 unqualified name**
* 包含名称空间的名称（如 Jack::pail）称为**限定名称 qualified name**

### using 声明和 using 编译指令

我们不希望每次使用名称都对它进行限定，因此 C++ 提供了两种机制

**using 声明**

* 使得特定的标识符可用

```cpp
using Jill::fetch;
```

* 完成该声明后，可以使用名称 fetch 替代 Jill::fetch
* 将覆盖同名全局变量
* 编译器不允许同时为两个相同标识符使用 using 声明，如 using Jack::pal，using Jill::pal

**using 编译指令**

* 使得整个名称空间可用

```cpp
using namespace Jack; 
```

* 它们增加了名称冲突的可能性
* 将覆盖同名的全局变量

### 名称空间嵌套

```cpp
namespace elements
{
    namespace fire
    {
        int flame;
    }

    float water;
}
```

则在引用 flame 的时候可以采用 elements::fire::flame

### 名称空间别名

可以给名称空间创造别名，假设有下面的名称空间

```cpp
namespace hello
{
    ...
}
```

可以使用下里面的语句让 hi 称为 hello 的别名

```cpp
namespace hi = hello;
```

也可以使用这种技术来简化对嵌套名称空间的使用

```cpp
namespace MEF = myth::elements::fire;
```

## 3.3 名称空间的应用

* 使用在已命名的名称空间中声明的变量，而不是使用外部的全局变量
* 使用在已命名的名称空间中声明的变量，而不是使用静态全局变量
* 如果开发了一个函数库或者类库，将其放在一个明康称空间中
* 不要在头文件中使用 using 编译指令
* 导入名称时，首选使用作用域解析运算符或者 using 声明的方法
* 对于 using 的声明，首选将其作用域设置为局部而不是全局

