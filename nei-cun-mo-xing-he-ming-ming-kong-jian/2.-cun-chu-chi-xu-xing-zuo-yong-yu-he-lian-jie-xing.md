# 2. 存储持续性、作用域和链接性

## 1. 存储数据的方式

C++ 使用 4 种不同的方案来存储数据，这些方案的区别在于数据保留在内存中的时间

* **自动存储持续性**：函数中声明的变量 在函数开始执行所属代码时创建，在函数执行完后被释放
* **静态存储持续性**：函数定义外定义的变量和使用关键字 static 定义的变量 在整个程序执行的过程中都存在
* **线性存储持续性**：让程序能够将计算放在可并行处理的不同线程中 如果变量使用关键字 thread\_local 声明，则其生命周期和所属线程一样长
* **动态存储持续性**：用 new 运算符分配的内存 一直存在，直到使用 delete 运算符将其释放或程序结束为止

## 2. 自动存储持续性

假设在 main\(\) 的开头定义了一个名为 teledeli 的变量，然后开始了一个心的代码块，并在其中定义了一个新的变量 websight，则 teledeli 在内部代码块和外部代码块中都是课件的，而 websight 就只在内部代码块中可见

如果内部和外部代码块中的变量名相同，那么新的定义隐藏了之前的定义，新定义可见，旧定义暂时不可见，当程序离开该代码块时，原来的定义重新可见

为了维护自动存储，C++ 使用栈的结构来分配内存，新数据放在旧数据的上面

## 3. 静态持续变量

C++ 为静态连续变量提供了 3 中链接性

* **外部链接性**：可在其它文件中访问
  * 在代码块的外部声明
* **内部链接性**：可在当前文件中访问
  * 在代码块的外部声明，且必须加关键字 static
* **无链接性**：只能在当前函数或代码块中访问
  * 在代码块的内部声明

### 5 种变量存储方式

| 存储描述 | 持续性 | 作用域 | 链接性 | 声明方式 |
| :--- | :--- | :--- | :--- | :--- |
| 自动 | 自动 | 代码块 | 无 | 在代码块中 |
| 寄存器 | 自动 | 代码块 | 无 | 在代码块中，使用关键字 register |
| 静态、无链接性 | 静态 | 代码块 | 无 | 在代码块中，使用关键字 static |
| 静态、内部链接性 | 静态 | 文件 | 内部 | 不在任何函数内，使用关键字 static |
| 静态、外部链接性 | 静态 | 文件 | 外部 | 不在任何函数中 |

### 静态变量的初始化

* **零初始化**
  * 将变量设置成零
  * 标量类型变量中，零被转换为合适的类型
  * 空指针用 0 表示，其内部可能采用非零
  * 结构成员被零初始化
* **常量表达式初始化**
* **动态初始化**
  * 如果没有足够的信息，进行动态初始化

```cpp
int x;                            //零初始化
int y = 5;                        //常量表达式初始化
int z = 13 * 13;                  //常量表达式初始化
const double pi = 4.0 * atan(1.0);//动态初始化
```

* **零初始**化和**常量表达式初始化**被统称为**静态初始化**
* 所有的静态变量，不管采用什么初始化方式，**都会被零初始化**
* 如果使用常量表达式初始化，那么接下来编译器仅根据文件内容即可计算表达式
* 要初始化 pi，必须调用函数 atan\(\)，这需要**等到该函数被链接且程序执行时**

### 静态外部链接性变量的使用

* **定义声明**
  * 当第一次初始化某一静态外部连结性变量时，需要声明
  * 它给变量分配内存空间
  * 此时定义方法有两种

```cpp
int process = 0;     // 与常规变量的定义没有很大区别
extern process = 0;  // 用 extern 表示
```

* **引用声明**
  * 当其它文件想要引用已经定义了的外部链接性变量时使用
  * 它不给变量分配内存空间

```cpp
extern process; // 引用声明
```

* 如果函数中声明了一个与外部变量**同名**的变量，这种变量将被视为一个**自动变量**的定义
* 当程序执行到其所属函数时，该变量位于作用域内，**隐藏了同名的静态变量**
* C++ 提供**作用域运算解析符（::）**，放在变量名前面时，该运算符表示使用变量的**全局版本**

### 静态内部链接性变量的使用

如果在两个文件中同时存在相同名称（且均初始化）的静态外部链接性变量，程序将报错

```cpp
//file1
int errors = 20;
...
//////////////////////////////////////////
//file2
int errors = 5;
void print()
{
    cout << errors; // 报错
}
```

如果两个文件中，一个变量为静态外部链接性，而另一个为静态内部链接性，则内部链接性的变量所在文件不会报错，且隐藏外部的变量，使用自己内部的

### 静态存储持续性，无链接性变量的使用

在代码块中使用 static 初始化的变量

* 虽然该变量仅在该代码块中可用，但是它在该代码块不处于活动状态时依然存在
* 如果初始化了静态局部变量，程序只在启动的时候进行一次初始化，以后再调用函数时，不会像自动变量一样再初始化

