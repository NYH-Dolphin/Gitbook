# 2. 存储持续性、作用域和链接性

## 1. 存储数据的方式

C++ 使用 4 种不同的方案来存储数据，这些方案的区别在于数据保留在内存中的时间

* **自动存储持续性**：函数中声明的变量 在函数开始执行所属代码时创建，在函数执行完后被释放
* **静态存储持续性**：函数定义外定义的变量和使用关键字 static 定义的变量 在整个程序执行的过程中都存在
* **线性存储持续性**：让程序能够将计算放在可并行处理的不同线程中 如果变量使用关键字 thread\_local 声明，则其生命周期和所属线程一样长
* **动态存储持续性**：用 new 运算符分配的内存 一直存在，直到使用 delete 运算符将其释放或程序结束为止

## 2. 自动存储持续性

假设在 main\(\) 的开头定义了一个名为 teledeli 的变量，然后开始了一个心的代码块，并在其中定义了一个新的变量 websight，则 teledeli 在内部代码块和外部代码块中都是课件的，而 websight 就只在内部代码块中可见

如果内部和外部代码块中的变量名相同，那么新的定义隐藏了之前的定义，新定义可见，旧定义暂时不可见，当程序离开该代码块时，原来的定义重新可见

为了维护自动存储，C++ 使用栈的结构来分配内存，新数据放在旧数据的上面

## 3. 静态持续变量

C++ 为静态连续变量提供了 3 中链接性

* **外部链接性**：可在其它文件中访问
  * 在代码块的外部声明
* **内部链接性**：可在当前文件中访问
  * 在代码块的外部声明，且必须加关键字 static
* **无链接性**：只能在当前函数或代码块中访问
  * 在代码块的内部声明

### 5 种变量存储（分配内存）方式

| 存储描述 | 持续性 | 作用域 | 链接性 | 声明方式 |
| :--- | :--- | :--- | :--- | :--- |
| 自动 | 自动 | 代码块 | 无 | 在代码块中 |
| 寄存器 | 自动 | 代码块 | 无 | 在代码块中，使用关键字 register |
| 静态、无链接性 | 静态 | 代码块 | 无 | 在代码块中，使用关键字 static |
| 静态、内部链接性 | 静态 | 文件 | 内部 | 不在任何函数内，使用关键字 static |
| 静态、外部链接性 | 静态 | 文件 | 外部 | 不在任何函数中 |

### 静态变量的初始化

* **零初始化**
  * 将变量设置成零
  * 标量类型变量中，零被转换为合适的类型
  * 空指针用 0 表示，其内部可能采用非零
  * 结构成员被零初始化
* **常量表达式初始化**
* **动态初始化**
  * 如果没有足够的信息，进行动态初始化

```cpp
int x;                            //零初始化
int y = 5;                        //常量表达式初始化
int z = 13 * 13;                  //常量表达式初始化
const double pi = 4.0 * atan(1.0);//动态初始化
```

* **零初始**化和**常量表达式初始化**被统称为**静态初始化**
* 所有的静态变量，不管采用什么初始化方式，**都会被零初始化**
* 如果使用常量表达式初始化，那么接下来编译器仅根据文件内容即可计算表达式
* 要初始化 pi，必须调用函数 atan\(\)，这需要**等到该函数被链接且程序执行时**

### 静态外部链接性变量的使用

* **定义声明**
  * 当第一次初始化某一静态外部连结性变量时，需要声明
  * 它给变量分配内存空间
  * 此时定义方法有两种

```cpp
int process = 0;     // 与常规变量的定义没有很大区别
extern process = 0;  // 用 extern 表示
```

* **引用声明**
  * 当其它文件想要引用已经定义了的外部链接性变量时使用
  * 它不给变量分配内存空间

```cpp
extern process; // 引用声明
```

* 如果函数中声明了一个与外部变量**同名**的变量，这种变量将被视为一个**自动变量**的定义
* 当程序执行到其所属函数时，该变量位于作用域内，**隐藏了同名的静态变量**
* C++ 提供**作用域运算解析符（::）**，放在变量名前面时，该运算符表示使用变量的**全局版本**

### 静态内部链接性变量的使用

如果在两个文件中同时存在相同名称（且均初始化）的静态外部链接性变量，程序将报错

```cpp
//file1
int errors = 20;
...
//////////////////////////////////////////
//file2
int errors = 5;
void print()
{
    cout << errors; // 报错
}
```

如果两个文件中，一个变量为静态外部链接性，而另一个为静态内部链接性，则内部链接性的变量所在文件不会报错，且隐藏外部的变量，使用自己内部的

### 静态局部变量的使用

在代码块中使用 static 初始化的变量

* 虽然该变量仅在该代码块中可用，但是它在该代码块不处于活动状态时依然存在
* 如果初始化了静态局部变量，程序只在启动的时候进行一次初始化，以后再调用函数时，不会像自动变量一样再初始化

## 4. 说明符和限定符

### 存储说明符 storage class specifier 

* **auto**
  * 用于自动类型替换
* **register**
  * 声明指示寄存器存储
* **static**
  * 根据上面的内容，有不同的作用
* **extern**
  * 引用声明
* **thread\_local**
  * 指出变量的持续性与所属线程的持续性相同
* **mutable**
  * 指出，即使结构或类变量为 const，其中的某个成员也可以被修改

```cpp
struct data
{
    char name[30];
    mutable int accesses;
    ...
}

const data veep = {"hello",1, ...};
veep.accesses++;
```

* veep 的 const 限定符禁止程序修改 veep 的成员，但是 accesses 成员的 mutable 说明符使得 accesses 不受这种限制

### cv-限定符

* **const**
  * 内存被初始化后就不再被修改
  * 默认情况下，全局变量的链接性为外部的，但是 const 全局变量的链接性为内部的，在 C++ 看来，全局 const 定义就像使用了 static 说明符一样
  * `const int fingers = 10; == static const int fingers = 10;`
  * 如果出于某种原因，程序员希望某个常量的链接性是外部的，则可以使用 extern 关键字来覆盖默认的内部链接性 `extern const char * warning` 即使在定义这个变量的时候也必须使用 extern
* **vilatile**
  * 即使代码没有对内存单元进行修改，其值也可能发生变化

## 5. 函数和链接性

### 函数的链接性

* C++ 不允许在一个函数中定义另外一个函数，因此**所有函数的存储持续性都是静态**的，即在整个程序执行期间都是存在的
* 在**默认情况**下，**函数的链接性为外部**的，即可以在文件之间共享
* 可以在原型中使用关键字 **extern** 指出函数是在另一个文件中定义的
* 可以使用 **static** 关键字将函数的链接性设置成**内部**的，使之只能在一个文件中使用，必须在**原型和函数定义**中都使用此关键字
* 静态内部链接性的函数会**覆盖**外部定义

### C++ 在哪里查找函数

* 如果文件中的函数原型指出函数是静态内部链接性的
  * 编译器只在该文件中查找函数定义
* 否则
  * 编译器将在所有程序文件中查找
    * 如果找到两个定义
      * 报错
    * 如果所有程序文件中没有找到
      * 在库中搜索
    * 如果在程序文件中找到了
      * 不管是否与库中函数名称重名，编译器都会使用程序文件中定义的函数

## 6. 存储方案和动态分配

### 动态内存

* 使用 new （C++）或 malloc\(\) （C） 分配的内存
* new 负责在堆中找到一个足以满足要求的内存块
* 受运算符 new 和 delete 控制，而不是由作用域和链接性的规则控制
* 可以在一个函数中分配内存，而在另一个函数中将其释放
* 其分配和释放顺序要取决于 new 和 delete 在何时以何种方式被使用

### 跟踪动态内存的指针变量

假设在一个函数中包含下面语句

```cpp
float * p_fees = new float[20];
```

* 存储方案仍是用于跟踪动态内存的指针变量
* 由 new 分配的 80 个字节（假设 float 为 4 个字节）的内存将一直保留在内存中，直到 delete 运算符将其释放
* 包含该声明语句执行完毕后，p\_fees 指针将消失
* 如果希望一个函数能使用这 80 字节的内容，需要将其地址传递或返回给该函数

### 定位 new 运算符

还不太理解

