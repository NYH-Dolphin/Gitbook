# 2. 引用变量

## 1. 创建引用变量

C 和 C++ 使用 & 符号来表示变量的地址，但 C++ 给 & 符号赋予了另一个含义，将其用来声明引用

例如，要将 rodents 作为 rats 变量的别名

```cpp
int rats;
int & rodents = rats;
```

* & 不是地址运算符，而是类型标识符的一部分
* 上述引用声明允许将 rats 和 rodents 互换，它们指向相同的值和内存单元（**值和地址均相同**）
* 如果对 rodents 进行操作，比如 rodents++，那么 rats 相应的值也会改变
* 声明引用变量时，**必须将其初始化**

```cpp
int rats = 101;
int & rodents = rats;
int bunnies = 50;
rodents = bunnies; // rodents 和 rats 的值同时变成 50
```

* rodents 和 rats 的值同时变成了 50
* rodents 和 rats 的地址相同，与 bunnies 的地址不同

## 2. 将引用用作参数函数

引用经常被用作函数参数，使函数中的变量名称成为调用程序中的变量的别名，这种传递参数的方式称为按引用传递

![&#x6309;&#x503C;&#x4F20;&#x9012;&#x548C;&#x6309;&#x5F15;&#x7528;&#x4F20;&#x9012;](../.gitbook/assets/image%20%288%29.png)

为了访问原始数据，可以采用按引用传递和传递指针的方法

### 按引用传递函数声明

函数声明时，格式如下

```cpp
void grumpy(int & x);
void grumpy(int & x)
{
    ...
}
```

如果程序员想要在函数中**按引用传递**某个变量，并且**同时不能修改它的值**的话，可以把函数定义如下

```cpp
double refcube(const double &ra);
```

* 此时如果修改了 ra 的信息，编译器会报错
* 如果函数调用的参数不是左值或者与相应的 const 引用参数的类型不匹配，则 C++ 将创建类型的匿名变量，将函数调用参数的值传递给该**匿名变量**，并让**参数来引用该变量**

### 尽可能使用 const

将引用参数声明为常量数据的引用的理由有三个

* 使用 const 可以避免无意中修改数据导致编程错误
* 使用 const 使函数能够处理 const 和非 const 实参，否则将只能接受非 const 数据
* 使用 const 引用使函数能够正确生成并使用临时变量

## 3. 将引用用于结构

引用非常适合用于结构和类，使用结构引用参数的方式与使用基本变量引用相同，只需要在声明结构参数时使用引用运算符 & 即可

```cpp
struct free_throws
{
    std::string name;
    int made;
    int attempts;
    float percent;
};

void set_pc(free_throws & ft)
```

* 如果不希望函数修改传入的结构，可以使用 const

### 为何要返回引用

如果定义一个函数返回一个引用变量，那么它有什么好处呢？

```cpp
double m = sqrt(4.0);
cout << sqrt(25.0);
dup = accumulate(team, five);
```

* 4.0 被复制到一个临时位置，然后被赋值给 m
* 值 5.0 被复制到了一个临时变量，然后被传递给 cout
* 如果 accumulate\(\) 返回的是一个结构，而不是指向结构的引用，将把整个结构复制到一个临时位置，再将这个拷贝复制给 dup，而返回值如果是结构的引用的话，将直接把 team 复制到 dup，效率更高

### 返回引用需要注意的问题

应该避免返回函数终止时不再存在的内存单元的引用

```cpp
const free_throws & clone2(free_throws & ft)
{
    free_throws newguy;
    newguy = ft;
    return newguy;
}
```

* 返回一个指向临时变量 newguy 的引用
* 函数运行完毕后，newguy 将不复存在

为了避免这种情况，最简单的方法是返回一个作为参数传递给函数的引用

另一种方法是使用 new 来分配新的存储空间

```cpp
const free_throws & clone(free_throws & ft)
{
    free_throws * pt;
    *pt= ft;
    return pt;
}
```

* 创建一个无名的 free\_throws 结构，并让指针 pt 指向该结构，因此 \*pt 就是该结构
* 上述代码似乎会返回结构，但是函数声明表明，该函数实际上将返回这个结构的引用，这样便可以通过如下方法使用该结构

```cpp
free_throws & jolly = clone(three);
```

* 使得 jolly 成为新结构的引用，并让指针 pt 指向该结构，因此 \*pt 就是该结构

## 4. 什么时候使用引用

使用引用参数的主要原因有

* 程序员能够修改调用函数的数据对象
* 通过引用传递而不是整个数据对象，可以提高程序运行速度

对于使用传递的值而不做修改的函数

* 如果数据对象很小，如内置数据类新或者小型结构，则按值传递
* 如果数据对象是数组，则使用指针，并将指针声明为指向 const 的指针
* 如果数据对象是较大的结构，则使用指向 const 的指针或引用
* 如果数据对象是类对象，则使用 const 引用

对于修改调用函数中数据的函数

* 如果数据对象是内置数据类型，则使用指针
* 如果数据对象是数组，则使用指针
* 如果数据对象是结构，则使用引用或指针
* 如果数据对象是类对象，则使用引用

